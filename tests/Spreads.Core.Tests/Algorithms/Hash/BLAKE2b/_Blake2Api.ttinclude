//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable CS1573 // missing param XML

using System;


namespace Spreads.Algorithms.Hash.BLAKE2b
{
	/// <summary>Static helper methods for BLAKE2<#= alg.suffix #> hashing.</summary>
	internal static class Blake2<#= alg.suffix #>
	{
		/// <summary>The default hash digest length in bytes.  For BLAKE2<#= alg.suffix #>, this value is <#= alg.bits #>.</summary>
		public const int DefaultDigestLength = Blake2<#= alg.suffix #>Context.HashBytes;

		/// <inheritdoc cref="ComputeHash(int, ReadOnlySpan{byte}, ReadOnlySpan{byte})" />
		public static byte[] ComputeHash(ReadOnlySpan<byte> input) => ComputeHash(DefaultDigestLength, default, input);

		/// <inheritdoc cref="ComputeHash(int, ReadOnlySpan{byte}, ReadOnlySpan{byte})" />
		public static byte[] ComputeHash(int digestLength, ReadOnlySpan<byte> input) => ComputeHash(digestLength, default, input);

		/// <inheritdoc cref="ComputeHash(int, ReadOnlySpan{byte}, ReadOnlySpan{byte})" />
		public static byte[] ComputeHash(ReadOnlySpan<byte> key, ReadOnlySpan<byte> input) => ComputeHash(DefaultDigestLength, key, input);

		/// <summary>Perform an all-at-once BLAKE2<#= alg.suffix #> hash computation.</summary>
		/// <remarks>If you have all the input available at once, this is the most efficient way to calculate the hash.</remarks>
		/// <param name="digestLength">The hash digest length in bytes.  Valid values are 1 to <#= alg.bits #>.</param>
		/// <param name="key">0 to <#= alg.bits #> bytes of input for initializing a keyed hash.</param>
		/// <param name="input">The message bytes to hash.</param>
		/// <returns>The computed hash digest from the message bytes in <paramref name="input" />.</returns>
		public static byte[] ComputeHash(int digestLength, ReadOnlySpan<byte> key, ReadOnlySpan<byte> input)
		{
			var ctx = default(Blake2<#= alg.suffix #>Context);
			ctx.Init(digestLength, key);
			ctx.Update(input);
			return ctx.Finish();
		}

		/// <inheritdoc cref="ComputeAndWriteHash(ReadOnlySpan{byte}, ReadOnlySpan{byte}, Span{byte})" />
		public static void ComputeAndWriteHash(ReadOnlySpan<byte> input, Span<byte> output) => ComputeAndWriteHash(DefaultDigestLength, default, input, output);

		/// <inheritdoc cref="ComputeAndWriteHash(int, ReadOnlySpan{byte}, ReadOnlySpan{byte}, Span{byte})" />
		public static void ComputeAndWriteHash(int digestLength, ReadOnlySpan<byte> input, Span<byte> output) => ComputeAndWriteHash(digestLength, default, input, output);

		/// <inheritdoc cref="ComputeAndWriteHash(int, ReadOnlySpan{byte}, ReadOnlySpan{byte}, Span{byte})" />
		/// <param name="output">Destination buffer into which the hash digest is written.  The buffer must have a capacity of at least <see cref="DefaultDigestLength" />(<#= alg.bits #>) bytes.</param>
		public static void ComputeAndWriteHash(ReadOnlySpan<byte> key, ReadOnlySpan<byte> input, Span<byte> output) => ComputeAndWriteHash(DefaultDigestLength, key, input, output);

		/// <summary>Perform an all-at-once BLAKE2<#= alg.suffix #> hash computation and write the hash digest to <paramref name="output" />.</summary>
		/// <remarks>If you have all the input available at once, this is the most efficient way to calculate the hash.</remarks>
		/// <param name="digestLength">The hash digest length in bytes.  Valid values are 1 to <#= alg.bits #>.</param>
		/// <param name="key">0 to <#= alg.bits #> bytes of input for initializing a keyed hash.</param>
		/// <param name="input">The message bytes to hash.</param>
		/// <param name="output">Destination buffer into which the hash digest is written.  The buffer must have a capacity of at least <paramref name="digestLength" /> bytes.</param>
		public static void ComputeAndWriteHash(int digestLength, ReadOnlySpan<byte> key, ReadOnlySpan<byte> input, Span<byte> output)
		{
			if (output.Length < digestLength)
				throw new ArgumentException($"Output buffer must have a capacity of at least {digestLength} bytes.", nameof(output));

			var ctx = default(Blake2<#= alg.suffix #>Context);
			ctx.Init(digestLength, key);
			ctx.Update(input);
			ctx.TryFinish(output, out int _);
		}

		/// <inheritdoc cref="CreateIncrementalHasher(int, ReadOnlySpan{byte})" />
		public static IBlake2Incremental CreateIncrementalHasher() => CreateIncrementalHasher(DefaultDigestLength, default);

		/// <inheritdoc cref="CreateIncrementalHasher(int, ReadOnlySpan{byte})" />
		public static IBlake2Incremental CreateIncrementalHasher(int digestLength) => CreateIncrementalHasher(digestLength, default);

		/// <inheritdoc cref="CreateIncrementalHasher(int, ReadOnlySpan{byte})" />
		public static IBlake2Incremental CreateIncrementalHasher(ReadOnlySpan<byte> key) => CreateIncrementalHasher(DefaultDigestLength, key);

		/// <summary>Create and initialize an incremental BLAKE2<#= alg.suffix #> hash computation.</summary>
		/// <remarks>If you will receive the input in segments rather than all at once, this is the most efficient way to calculate the hash.</remarks>
		/// <param name="digestLength">The hash digest length in bytes.  Valid values are 1 to <#= alg.bits #>.</param>
		/// <param name="key">0 to <#= alg.bits #> bytes of input for initializing a keyed hash.</param>
		/// <returns>An <see cref="IBlake2Incremental" /> interface for updating and finalizing the hash.</returns>
		public static IBlake2Incremental CreateIncrementalHasher(int digestLength, ReadOnlySpan<byte> key)
		{
			var ctx = default(Blake2<#= alg.suffix #>Context);
			ctx.Init(digestLength, key);
			return ctx;
		}

	}
}
