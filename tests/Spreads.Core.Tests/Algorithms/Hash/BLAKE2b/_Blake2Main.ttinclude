//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

#if HAS_INTRINSICS
using System.Runtime.Intrinsics.X86;
#endif

namespace Spreads.Algorithms.Hash.BLAKE2b
{
	unsafe public partial struct Blake2<#= alg.suffix #>Context
	{
		public const int WordSize = sizeof(<#= alg.wtype #>);
		public const int BlockWords = 16;
		public const int BlockBytes = BlockWords * WordSize;
		public const int HashWords = 8;
		public const int HashBytes = HashWords * WordSize;
		public const int MaxKeyBytes = HashBytes;
<#
		//public const int SaltBytes = 2 * WordSize;
		//public const int PersonalizationBytes = 2 * WordSize;
#>

<#
		// BE platforms can't use the Span<byte> version of the IV. This builds it in the native type.
		/*
		private static readonly [#= alg.wtype #][] iv = new[] {
			[#= string.Format(alg.ivfmt, alg.iv[0]) #], [#= string.Format(alg.ivfmt, alg.iv[1]) #],
			[#= string.Format(alg.ivfmt, alg.iv[2]) #], [#= string.Format(alg.ivfmt, alg.iv[3]) #],
			[#= string.Format(alg.ivfmt, alg.iv[4]) #], [#= string.Format(alg.ivfmt, alg.iv[5]) #],
			[#= string.Format(alg.ivfmt, alg.iv[6]) #], [#= string.Format(alg.ivfmt, alg.iv[7]) #]
		};
		*/

#>
		private fixed byte b[BlockBytes];
		private fixed <#= alg.wtype #> h[HashWords];
		private fixed <#= alg.wtype #> t[2];
		private fixed <#= alg.wtype #> f[2];
		private uint c;
		private uint outlen;

		private static ReadOnlySpan<byte> ivle => new byte[] {
<#
for (int i = 0; i < alg.iv.Length; i++) {
	string s = "\t\t\t";
	for (int j = 0; j < alg.bits / 8; j++)
		s += $"{(j > 0 ? " " : null)}0x{(byte)(alg.iv[i] >> (j * 8)):X2},";
	WriteLine(i < alg.iv.Length - 1 ? s : s.Substring(0, s.Length - 1));
}
#>
		};

#if HAS_INTRINSICS
		private static ReadOnlySpan<byte> rormask => new byte[] {
<#
if (alg.bits == 64) {
#>
			3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10, //r24
			2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9  //r16
<#
} else {
#>
			2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13, //r16
			1, 2, 3, 0, 5, 6, 7, 4, 9, 10, 11, 8, 13, 14, 15, 12  //r8
<#
}
#>
		};
#endif

		public int DigestLength => (int)outlen;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void compress(ref byte input, uint offs, uint cb)
		{
			uint inc = Math.Min(cb, BlockBytes);

			fixed (byte* pinput = &input)
			fixed (Blake2<#= alg.suffix #>Context* s = &this)
			{
				<#= alg.wtype #>* sh = s->h;
				byte* pin = pinput + offs;
				byte* end = pin + cb;

				do
				{
					t[0] += inc;
					if (t[0] < inc)
						t[1]++;

					<#= alg.wtype #>* m = (<#= alg.wtype #>*)pin;
<#
					// For BE platforms, the input words must be byte swapped use the b[] array to store them and swap out the input pointer
					/*
					if (!BitConverter.IsLittleEndian)
					{
						var span = new ReadOnlySpan<byte>(pin, BlockBytes);
						m = ([#= alg.wtype #]*)s->b;
						for (int i = 0; i < BlockWords; i++)
							m[i] = BinaryPrimitives.ReadUInt[#= alg.bits #]LittleEndian(span.Slice(i * WordSize, WordSize));
					}
					*/

#>
#if HAS_INTRINSICS
<#
if (alg.bits == 64) {
#>
					if (Avx2.IsSupported)
						mixAvx2(sh, m);
					else
<#
}
#>
					if (Sse41.IsSupported)
						mixSse41(sh, m);
					else
#endif
						mixScalar(sh, m);

					pin += inc;
				} while (pin < end);
			}
		}

		public void Init(int digestLength = HashBytes, ReadOnlySpan<byte> key = default)
		{
			uint keylen = (uint)key.Length;

			if (!BitConverter.IsLittleEndian) ThrowHelper.NoBigEndian();
			if (digestLength == 0 || (uint)digestLength > HashBytes) ThrowHelper.DigestInvalidLength(HashBytes);
			if (keylen > MaxKeyBytes) ThrowHelper.KeyTooLong(MaxKeyBytes);

			outlen = (uint)digestLength;

<#
			// Use the Span<byte> IV for perf improvements on LE platforms, or the array for BE
			/*
			if (BitConverter.IsLittleEndian)
				Unsafe.CopyBlockUnaligned(ref Unsafe.As<[#= alg.wtype #], byte>(ref h[0]), ref MemoryMarshal.GetReference(ivle), HashBytes);
			else
				Unsafe.CopyBlockUnaligned(ref Unsafe.As<[#= alg.wtype #], byte>(ref h[0]), ref Unsafe.As<[#= alg.wtype #], byte>(ref iv[0]), HashBytes);
			*/

#>
			Unsafe.CopyBlockUnaligned(ref Unsafe.As<<#= alg.wtype #>, byte>(ref h[0]), ref MemoryMarshal.GetReference(ivle), HashBytes);
			h[0] ^= 0x01010000u ^ (keylen << 8) ^ outlen;

<#
			// Salt and Personalization support can be added like this, assuming ReadOnlySpan<byte> args.
			// I just didn't want to deal with all the extra overloads and parameter validation.
			/*
			if ((salt.Length != 0)
			{
				ref [#= alg.wtype #] rs = ref Unsafe.As<byte, [#= alg.wtype #]>(ref salt[0]);
				h[4] ^= rs;
				h[5] ^= Unsafe.Add(ref rs, 1);
			}
			if ((personalization.Length != 0)
			{
				ref [#= alg.wtype #] rp = ref Unsafe.As<byte, [#= alg.wtype #]>(ref personalization[0]);
				h[6] ^= rp;
				h[7] ^= Unsafe.Add(ref rp, 1);
			}
			*/

#>
			if (keylen != 0)
			{
				Unsafe.CopyBlockUnaligned(ref b[0], ref MemoryMarshal.GetReference(key), keylen);
				c = BlockBytes;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Update(ReadOnlySpan<byte> input)
		{
			if (f[0] != 0) ThrowHelper.HashFinalized();

			uint consumed = 0;
			uint remaining = (uint)input.Length;
			ref byte rinput = ref MemoryMarshal.GetReference(input);

			uint blockrem = BlockBytes - c;
			if ((c != 0) && (remaining > blockrem))
			{
				if (blockrem != 0)
					Unsafe.CopyBlockUnaligned(ref b[c], ref rinput, blockrem);

				c = 0;
				compress(ref b[0], 0, BlockBytes);
				consumed += blockrem;
				remaining -= blockrem;
			}

			if (remaining > BlockBytes)
			{
				uint cb = (remaining - 1) & ~((uint)BlockBytes - 1);
				compress(ref rinput, consumed, cb);
				consumed += cb;
				remaining -= cb;
			}

			if (remaining != 0)
			{
				Unsafe.CopyBlockUnaligned(ref b[c], ref Unsafe.Add(ref rinput, (int)consumed), remaining);
				c += remaining;
			}
		}

		public void Update<T>(ReadOnlySpan<T> input) where T : struct
		{
			ThrowHelper.ThrowIfIsRefOrContainsRefs<T>();

			Update(MemoryMarshal.AsBytes(input));
		}

		private void finish(Span<byte> hash)
		{
			if (f[0] != 0) ThrowHelper.HashFinalized();

			if (c < BlockBytes)
				Unsafe.InitBlockUnaligned(ref b[c], 0, BlockBytes - c);

			f[0] = ~0<#= alg.wsuff #>;
			compress(ref b[0], 0, c);

<#
			// For BE platforms, the hash words need to be byte swapped.
			/*
			if (!BitConverter.IsLittleEndian)
			{
				var span = MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<[#= alg.wtype #], byte>(ref h[0]), HashBytes);
				for (int i = 0; i < HashWords; i++)
					h[i] = BinaryPrimitives.ReadUInt[#= alg.bits #]LittleEndian(span.Slice(i * WordSize, WordSize));
			}
			*/

#>
			Unsafe.CopyBlockUnaligned(ref hash[0], ref Unsafe.As<<#= alg.wtype #>, byte>(ref h[0]), outlen);
		}

		public byte[] Finish()
		{
			byte[] hash = new byte[outlen];
			finish(hash);

			return hash;
		}

		public bool TryFinish(Span<byte> output, out int bytesWritten)
		{
			if ((uint)output.Length < outlen)
			{
				bytesWritten = 0;
				return false;
			}

			finish(output);
			bytesWritten = (int)outlen;
			return true;
		}
	}
}
